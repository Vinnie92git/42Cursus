Get Next Line

<aparte>
üìÉ *Lo que necesitaba aprender para construir el proyecto get_next_line. ¬°Consejos, explicaciones, diagramas y c√≥digo, compartiendo con el deseo de ayudar a otros cadetes a abordar el proyecto m√°s r√°pido! ¬°Si√©ntete libre de comentar y contribuir!*

</aparte>

> **palabras clave: variable est√°tica, descriptor de archivo (fd), lectura de archivo**
>

<aparte>
‚ö†Ô∏è Sabemos que no todos tienen el privilegio de poder dedicar el 100% de su tiempo √≠ntegramente a 42. Estas gu√≠as fueron creadas con el objetivo de agilizar el proceso de averiguar qu√© conocimientos se necesitan para poder resolver el problema propuesto por el proyecto, ahorrando dinero Tiempo valioso para codificar. He evitado dar soluciones listas para usar en la medida de lo posible, porque dise√±ar, implementar, probar y construir la soluci√≥n tambi√©n es parte de su aprendizaje en 42. Aun as√≠, esta p√°gina puede contener algunos spoilers de implementaci√≥n, ¬°as√≠ que proceda con precauci√≥n!

</aparte>

# Para entender antes de empezar

En primer lugar, intente buscar en Google c√≥mo leer un archivo en C. ¬øQu√© funciones uso? ¬øC√≥mo se entiende un archivo dentro de un programa en C? ¬øQu√© representa el archivo, es una variable, un puntero, un n√∫mero, un objeto (estructura)? ¬øQu√© puedo hacer con un archivo usando el lenguaje C? Experimente, intente abrir un archivo en main, luego cambie la direcci√≥n del archivo (cree una carpeta y p√≥ngala dentro), vea c√≥mo se comporta el programa...

Estoy descubriendo que para leer un archivo, primero necesito abrirlo, y para abrir un archivo hay dos funciones (`open()` o `fopen()`); para leer el archivo hay dos funciones (`read()` o `fgetc()`), con diferentes argumentos y dem√°s. Trate de encontrar ejemplos de c√≥digos que abran y lean un archivo (independientemente de las funciones) y trate de entender lo que est√° sucediendo primero. Luego comienza a dirigir su b√∫squeda m√°s hacia la funci√≥n `read()` en s√≠ misma, que es la funci√≥n que pdf le permite usar. A partir de ah√≠, aqu√≠ tienes la lista de temas que te pueden ayudar a entender mejor el problema:

### funci√≥n read()

Adem√°s de leer el manual, toma la funci√≥n e intenta leer algo, un archivo, entrada de terminal, dale una buena jugada para saber c√≥mo funciona. ¬øQu√© sucede cuando la funci√≥n llega al final del archivo? ¬øQu√© pasa si el b√∫fer es mucho m√°s grande que la cantidad de caracteres en el archivo? ¬øQu√© pasa si el b√∫fer es 1? ¬øQu√© pasa si el archivo est√° vac√≠o? ¬øQu√© sucede si el archivo no existe (fd aleatorio)?

Realice varias pruebas con la funci√≥n de lectura leyendo el mismo archivo, cambiando el tama√±o del b√∫fer y observando el retorno de la funci√≥n y la cadena que ley√≥.

### File Descriptor

Es un n√∫mero que identifica un archivo al ejecutar un programa. ¬øCu√°l es el valor m√°ximo de un archivo descriptor? ¬øEs esto lo mismo que el n√∫mero m√°ximo de archivos que se pueden abrir en un programa a la vez?

### Qu√© es una macro y c√≥mo definirla en tiempo de compilaci√≥n

Las macros son fragmentos de c√≥digo que reciben un nombre, y a partir de ah√≠ se pueden replicar (expandir) en otras partes de un archivo de c√≥digo fuente (`*.c`), para comodidad de quienes escriben el c√≥digo. Expandir una macro es lo mismo que hacer `ctrl+C`, `ctrl+V` de un fragmento de c√≥digo de un lugar a otro, pero el preprocesador hace este trabajo al compilar el c√≥digo que escribiste.

Puede parecer un concepto nuevo y extra√±o, ¬°pero has estado usando este concepto durante mucho tiempo! El `#include <algumalib.h>` que usamos desde basecamp es como una macro, de hecho, un gran ejemplo de "copiar c√≥digo de otro lugar": la biblioteca que desea importar con el include (por ejemplo, `# include < stdio.h>`) est√° guardado en alg√∫n lugar de su computadora, probablemente fue escrito por otra persona (o usted mismo, en el caso de `#include "libft.h"`), y lo que hace esta l√≠nea de c√≥digo es copiar en su archivo de c√≥digo fuente (por ejemplo, `main.c`) el contenido del encabezado (`stdio.h`, que por regla general contiene prototipos, a veces funciones completas).

Hablando formalmente, tanto la inclusi√≥n de encabezados a trav√©s de `#include` como la definici√≥n de macros a trav√©s de `#define` son **directrices de preprocesamiento**, que es el paso intermedio que ocurre entre escribir el c√≥digo fuente y compilar el c√≥digo y convertirlo en binario. o biblioteca est√°tica. Este art√≠culo explica m√°s al respecto:

[](https://www.programiz.com/c-programming/c-preprocessor-macros)

Una macro puede definir varias l√≠neas de c√≥digo, ya que solo puede definir un valor fijo. Norma habla de macros y para este proyecto es importante que sepas lo que puedes y no puedes hacer usando macros.

Dado que las macros son directivas de preprocesamiento (lo que sucede antes de la compilaci√≥n), puede crear macros cuando escribe su c√≥digo (usando https://www.rapidtables.com/code/linux/gcc/gcc-d.html](https://www.rapidtables.com/code/linux/gcc/gcc-d.html) (use esta bandera para establecer el BUFFER_SIZE)

### Variable est√°tica

Comprender el concepto de una variable est√°tica es importante y tambi√©n es importante comprender c√≥mo implementarla. Nada fuera de este mundo: inicializas la variable en el mismo momento aquel en que lo declaras. Esto es contrario a la intuici√≥n porque hasta ahora, el est√°ndar nos ha dicho expl√≠citamente que no inicialicemos las variables en el momento de la declaraci√≥n. Pero el propio est√°ndar hace esta excepci√≥n para las variables est√°ticas. Como la variable est√°tica se declara al comienzo de la funci√≥n, no tiene que preocuparse por liberar su memoria, esto sucede autom√°ticamente durante la ejecuci√≥n. Est√° bien, puedes continuar.

### Asignaci√≥n de memoria: pila vs. mont√≥n

De alguna manera logr√© sobrevivir a basecamp y [Accelera ‚Äî Libft](https://www.notion.so/Acelera-Libft-8874a01f188a4671ae503fe9e99056ab) hasta ahora sin tener CLARO una de las cosas que es fundamental en el lenguaje C y que lo diferencia de otros idiomas (adem√°s de punteros). Ese es el hecho de que la *manera* en que se asigna la memoria durante la ejecuci√≥n de su programa es relevante, **Y TAMBI√âN** es responsabilidad de quien escribe el programa. Las funciones `malloc()`/`calloc()` y `free()` dejan en manos del programador la tarea de utilizar la memoria RAM del SO que ejecutar√° el programa. Y esto es relevante a la hora de pensar c√≥mo voy a resolver el problema planteado en LNG: ¬øqu√© tipo de variables tengo en juego? ¬øAlguna cadena tiene una longitud fija, es decir, puedo predecir que la longitud de cualquiera de las variables siempre ser√° fija? ¬øAlguno tiene tama√±os variables? ¬øC√≥mo satisfago las necesidades de flexibilidad del retorno de la funci√≥n get_next_line? (que solo puede devolver una palabra, ¬øc√≥mo puede devolver una l√≠nea de 10,000 palabras?) ¬øC√≥mo satisfago la necesidad de la funci√≥n de lectura de tener un b√∫fer para recibir el contenido que se ley√≥?

El video que finalmente me ayud√≥ a comprender mejor qu√© es stack/heap fue [this CS50 class](https://www.youtube.com/watch?v=NKTfNv2T0FE), m√°s espec√≠ficamente en la marca de 1:48:00 (pero recomiendo ver toda la clase que es ü§Øü§Øü§Ø).

## Configurando tu prueba

get_next_line() es una funci√≥n intermedia, en el sentido de que Moulinette generar√° tanto un archivo para leer como un main para llamar a get_next_line(), pero no es la funci√≥n misma la que ***abre*** el archivo que ser√° leer (¬°la funci√≥n `abrir` no est√° permitida!) Simplemente ***lee*** un archivo que ***ya est√° abierto***.

GNL llamar√° a la funci√≥n `read()` (pasando el descriptor de archivo que le pas√≥ main), y luego procesar√° el resultado que recibe de read. Por lo tanto, para probar m√≠nimamente su funci√≥n, necesitar√°:

- Cualquier archivo de texto (ni siquiera necesita tener un `\n` dentro) para ser le√≠do;
- Un main que abre este archivo, hace lo que tiene que hacer (llama a gnl), posiblemente imprime el resultado de cada llamada a gnl, y luego cierra el archivo y finaliza la ejecuci√≥n;

Esto deber√≠a ser suficiente para "poner de pie" su funci√≥n de GNL mientras la construye.

Cuando se sienta listo para realizar pruebas m√°s exhaustivas de su funci√≥n, use los repositorios de pruebas automatizados [**desde este enlace**](https://docs.google.com/spreadsheets/d/1Ewfq-R65Ymko8qteJmLQJcv46l1OeaD-m8QBJ4s8TEs/ edit# gid=0).

---

# Explicaci√≥n del proyecto

Desde el prototipo de la funci√≥n `get_next_line()`, puede ver cu√°les son la entrada y la salida de la funci√≥n.

La entrada es un descriptor de archivo (fd), es decir, puede ser un archivo que se abri√≥ en main, como stdin (entrada est√°ndar: env√≠o de datos a trav√©s de la terminal), o por redirecci√≥n (stdout). Cualquier cosa que se pueda abrir e interpretar como un archivo con un archivo descrito puede ser el argumento de entrada de la funci√≥n.

La salida de la funci√≥n es una l√≠nea, es decir, una cadena de caracteres que termina en `\n` y que contiene solo un `\n`, excepto en los casos en que el archivo que se lee no contiene ning√∫n `\ n`, o no terminar con `\n`; en estos casos, la l√≠nea devuelta no necesita terminar en `\n`.

Solo puede usar la funci√≥n de lectura, que lee el archivo en partes y no analiza el contenido de lo que se ley√≥. As√≠ que es su trabajo en este proyecto implementar la l√≥gica para verificar si hay un `\n` dentro de lo que se ley√≥ por lectura, y luego ensamblar la l√≠nea de retorno de su funci√≥n get_next_line.

Entonces, si debe interrumpir el proceso de lectura cada vez que encuentre un `\n`, y este `\n` puede estar en cualquier posici√≥n dentro de su b√∫fer de lectura, entonces necesitar√° usar una variable est√°tica para almacenar todos los caracteres que vienen. despu√©s de `\n`, para que la informaci√≥n no se pierda una vez que la funci√≥n `get_next_line()` llegue al final y devuelva la l√≠nea. De modo que, en la siguiente ejecuci√≥n, la siguiente l√≠nea comience con los caracteres restantes de la ejecuci√≥n anterior.

## ¬øVamos a ver un ejemplo pr√°ctico?

Suponga que lee un archivo que contiene la cadena `"¬°Hola mundo!\nBlz?\n"` (16 bytes), como se muestra en la siguiente figura:

![Sin t√≠tulo](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9440acf2-c623-4e64-aee8-2d3bb317a899/Untitled.png)

Tenga en cuenta que el contenido del archivo contiene dos caracteres de nueva l√≠nea (`\n`). Significa que al leer este archivo por completo, su funci√≥n GNL deber√≠a ejecutarse dos veces, devolviendo una l√≠nea a la vez.

La funci√≥n `read()` maneja la lectura de solo caracteres BUFFER_SIZE a la vez. Supongamos que BUFFER_SIZE se estableci√≥ en 4 en el momento de la compilaci√≥n, es decir, al ejecutar el comando gcc, se agreg√≥ el indicador `-D BUFFER_SIZE=4`, representado en la siguiente figura por el **cuadro morado**:

![Sin t√≠tulo](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3df8d9e1-2155-4914-957f-3e09fd3cf936/Sin t√≠tulo.png)

Su funci√≥n es evaluar si hay un car√°cter `\n` dentro de lo le√≠do o no. Si es as√≠, entonces sabe que GNL deber√≠a devolver todo lo le√≠do hasta este car√°cter. De lo contrario, la lectura deber√≠a continuar, llamando a `read()` nuevamente. En nuestro ejemplo, **no hay** un `\n` dentro del b√∫fer. Por lo tanto, la lectura contin√∫a y la funci√≥n GNL no debe cerrarse todav√≠a, pero antes de iniciar la siguiente lectura `read()`, es necesario guardar todo lo que se ha le√≠do hasta el momento para construir la l√≠nea que se devolver√° como el `\n` se encuentra, ¬øverdad? ¬°Esto es contigo!

La siguiente lectura de `read()` devolver√° el siguiente bloque de caracteres:

![Sin t√≠tulo](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c92d898e-374f-4211-b745-cbe189fd836a/Untitled.png)

Del mismo modo, a√∫n no hemos encontrado un `\n` dentro del bloque que se ley√≥. Concatenamos todo este bloque de caracteres con los otros caracteres que se leyeron y llamamos a `read()` nuevamente.

![Sin t√≠tulo](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/99a4854b-2b8c-4268-928e-d3a54d91557e/Untitled.png)

¬°Ups! ¬°Esta vez tenemos un `\n` dentro del bloque! No solo eso, sino que hay un car√°cter justo despu√©s del car√°cter de nueva l√≠nea. Tenga en cuenta que cuando encuentra un `\n` en el b√∫fer `read()`, esta es la se√±al para que su funci√≥n GNL se detenga y devuelva la l√≠nea que se ley√≥. Pero, ¬øqu√© pasar√° con esa `B` que existe despu√©s de `\n`? Necesito guardarlo porque es el comienzo de la siguiente l√≠nea, pero mi funci√≥n GNL est√° a punto de salir...

Espero que a estas alturas ya hayas recopilado toda la informaci√≥n que necesitas para solucionar este problema ;) Si es necesario, revisa los conceptos de arriba, escribe borradores, pide ayuda, en fin, haz lo que sea necesario para proceder.

Vale la pena se√±alar que incluso cuando se cierra la funci√≥n GNL, el archivo permanece abierto y, por lo tanto, la funci√≥n `read ()` permanece en el mismo punto donde se detuvo en la √∫ltima lectura del archivo. Lo que significa que la pr√≥xima vez que se llame, leer√° los siguientes 4 caracteres, como se muestra en la siguiente figura:

![Sin t√≠tulo](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/83317e7a-63e0-4f74-8a7b-5f613f2261ae/Untitled.png)

Finalmente, cuando no hay m√°s caracteres para leer, la funci√≥n `read()` devuelve `0`, que es una se√±al para que la funci√≥n GNL devuelva `NULL`, lo que indica que no hay nada m√°s para leer del archivo. . No olvide liberar cualquier variable que haya sido asignada con `malloc` antes de finalizar la funci√≥n, para evitar p√©rdidas de memoria.

## Otro ejemplo (sin salto de l√≠nea)

Un ejemplo m√°s, esta vez un archivo sin saltos de l√≠nea y `BUFFER_SIZE = 5`. El contenido del archivo es: `"¬°La respuesta es 42!"` (16 bytes).

![Sin t√≠tulo](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bdc8389b-06f3-4041-a033-0e41cb45d531/Untitled.png)

La primera lectura de `read()` ser√° la siguiente:

![Sin t√≠tulo](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9d21f46a-5f5a-4571-8d93-6907e1b26667/Untitled.png)

En los primeros 5 bytes le√≠dos, no se encontraron nuevas l√≠neas. Debe almacenar el contenido de este b√∫fer para devolver la l√≠nea al final de la funci√≥n. La lectura contin√∫a:

![Sin t√≠tulo](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/37f1cf5c-d974-42c2-aa63-481d8b6ed496/Untitled.png)

Una vez m√°s, el resultado de la lectura no contiene saltos de l√≠nea. Por lo tanto, debe concatenar completamente este b√∫fer a la l√≠nea que se devolver√° al final de la funci√≥n. Y llama a `read()` de nuevo.

![Sin t√≠tulo](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fa647bb0-f907-476e-91ee-46802756119e/Untitled.png)

Por tercera vez, no hay saltos de l√≠nea en el contenido le√≠do. Significa que a√∫n no se ha encontrado el final de la l√≠nea. Guarde el contenido del b√∫fer y vuelva a llamar a la funci√≥n `read()`.

![Sin t√≠tulo](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2279c1b1-4d5c-40a8-9719-5ba6868f23ca/Untitled.png)

Tenga en cuenta que esta vez se leyeron menos de 5 bytes del archivo. La funci√≥n `read()` devuelve el n√∫mero de caracteres le√≠dos del archivo, en este caso, el retorno ser√° igual a `1`. Esto indica que se ha llegado al final del archivo (¬øve por qu√©?) Por lo tanto, una √∫ltima vez es necesario verificar si hay un salto de l√≠nea dentro del contenido que se acaba de leer. Si es as√≠, debe terminar su l√≠nea, guardar lo que queda del b√∫fer despu√©s del car√°cter `\n` (si corresponde), dar `free()` donde lo necesite y finalizar `get_next_line()` devolviendo el l√≠nea encontrada.

En nuestro caso, incluso al final del archivo, ¬°no encontramos un salto de l√≠nea! El pdf dice que en este caso n No es necesario "forzar" un `\n` al final de la l√≠nea. Por lo tanto, simplemente concatene todo lo que se ley√≥ en su l√≠nea y devu√©lvalo como retorno al final de la ejecuci√≥n.

¬°Buena suerte! üçÄ

---

# Paso a paso para construir el GNL

- [ ] Lea los caracteres `BUFFER_SIZE` usando `read()` tantas veces como sea necesario
- [ ] Encuentra el caracter `\n`
- [ ] Devuelve el texto le√≠do antes de `\n`
- [ ] Guarda el texto le√≠do despu√©s de `\n`, si lo hay
- [ ] Usar el texto guardado en la llamada anterior de GNL
- [ ] ¬øC√≥mo lidiar con cadenas m√°s grandes que `BUFFER_SIZE`?
- [ ] ¬øEn qu√© casos mi GNL deber√≠a devolver -1?

Para llegar m√°s lejos:

- [ ] (bonificaci√≥n) ¬øQu√© estructura de datos debo usar para manejar m√∫ltiples FD?
- [ ] ¬øC√≥mo debo tratar con el car√°cter `NULL`?
- [ ] ¬øDebo usar malloc en mi b√∫fer (funci√≥n de lectura) o usar una matriz de tama√±o fijo?

Desde su libft, eche un vistazo a las siguientes funciones: `strchr`, `strdup`, `strjoin`, `strdel`.

*(adaptado [**de este hilo**](https://discord.com/channels/@me/895737928469340160/895737932240023622) en slack de 42 Mundial)*

---

# Diagrama en Miro y mi Github

Hice un [diagrama en Miro](https://miro.com/app/board/o9J_l8sFQdU=/) que me ayud√≥ a comprender mejor el flujo de las cosas, los posibles escenarios, etc., pero al final, mi c√≥digo se desvi√≥ un mucho por la forma en que se hizo el dise√±o. Aqu√≠ te dejo el dibujo, tal vez te pueda ayudar. Cuando nada m√°s, aqu√≠ hay un consejo para hacer su propio diagrama para desarrollar y perfeccionar su razonamiento, hasta que se sienta c√≥modo para comenzar a codificar.

![get_next_line - Diagrama inicial (1).jpg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2d9fe18b-0e21-4382-aebd-da65d6d7019b/get_next_line_-_Initial_Diagram_ (1).jpg)

Y tambi√©n dejo el enlace a mi Github, escrib√≠ un hermoso README.me para explicar exactamente c√≥mo funciona el proyecto y c√≥mo ejecutar el programa para probarlo (aqu√≠ est√° el consejo si quieres un main.c simple listo para hacer tus pruebas ), siga o [**Github link**](https://github.com/rodsmade/Get_Next_Line-42sp).

![Sin t√≠tulo](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f4de9c62-66a8-4631-9b00-667e727384f4/Untitled.png)

---

# Contacto y Otros Proyectos

En Github puedes encontrar mis otros 42 proyectos **[en este enlace](https://github.com/rodsmade/Projets_42_SP/)**.

Para otros proyectos (que ya hice üòÖ), consulta la p√°gina [¬°Acelera 42cursus!](https://www.notion.so/Acelera-42cursus-400c86d2e61242338b010c23c6930134)

Si no tiene nada que necesite all√≠, b√∫squelo en [Notion dos Notions - Projetos da 42](https://www.notion.so/Notion-dos-Notions-Projetos-da-42-4e9bc573b5e84b10b91054510d6b4797).

Puedes encontrarme en Discord aqu√≠: **[Rods#3435](https://discordapp.com/users/rods#3435)**.
